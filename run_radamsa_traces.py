import os, signal
import sys
import multiprocessing
import subprocess

import utils.Operations.Operations as op
     

'''
#Initializing
#mkdir for core_index: outcome_1. 
#if outcome_1 not exists
#    mkdir:outcome_1/out, outcome_1/err
'''
def init_process(core_index, work_path):
    dir_existed = op.mkdir(work_path)
    
    if dir_existed:
        op.mkdir("%s/output" % work_path)#mutations_path
        op.mkdir("%s/input" % work_path)#dedup_path
        op.mkdir("%s/err" % work_path)#err_path

'''
Fuzzing:
Run cmd line to generate mutated outputs.
Save outputs as outcome_*/output/id_index.
'''
def fuzzing_process(core_index, mutations_path, fuzzer_path, mutation_num, seed_path):
    fuzzer_run_cmd = "%s -o %s/id_%s -n %d %s" % (fuzzer_path, mutations_path, "%n", mutation_num, seed_path)
    fuzzer_return = op.run_cmd(fuzzer_run_cmd)
    print("Core #%d generated %d mutations for testing." % (core_index, mutation_num))

'''
Testing:
Use outputs generated by the fuzzer&&deduped by alf-cmin to test the program cxxfilt.
@param: testing program_name
input_path: "12h-cxxfilt-zzuf/outcomes-1/input"
err_path: "12h-cxxfilt-zzuf/outcomes-1/err"
'''
def testing_process(core_index, input_path, err_path, program_path):
    # Get all file name under dir input_path.
    input_files = os.listdir("%s/" % input_path)
    print(input_files)
    # Test each file in the program to be tested.
    for onefile in input_files:
        test_input = "%s/%s" % (input_path, onefile)
        test_cmd = "%s < %s" % (program_path, test_input)
        test_return = op.run_cmd(test_cmd)
        test_out, test_err = test_return.communicate()
    
        #If the input crashes the program, copy it to err/ dir.
        if test_err:
              print("ERROR input file: %s" % onefile)
              print(test_err)
              err_destination = "%s/%s;timestamp_%s" % (err_path, onefile, op.get_now_timestamp())
              op.copyfile(test_input, err_destination)
'''
Remove duplicates using afl-cmin.
'''
def de_dup_process(core_index, program_path, input_path, output_path):
    #remove duplicates using afl-cmin "afl-cmin -i afl_in -o afl_out -m none -- cxxfilt"
    dedup_cmd = "afl-cmin -C -i %s -o %s -m none -- %s" % (input_path, output_path, program_path)
    print(dedup_cmd)
    dedup_pipe = os.popen(dedup_cmd)
    dedup_pipe.read()
    dedup_pipe.close()
    
'''
Run the fuzzing&testing subprocess:
Initialization, fuzzing, testing.
'''
def run_radamsa_subprocess(core_index, test_path, program_path, fuzzer_path, seed_path, mutation_num):

     init_process(core_index, "%s/outcomes-%d" % (test_path, core_index))
     print("Initialization done.")  
     while True:

          fuzzing_process(core_index, "%s/outcomes-%d/output" % (test_path, core_index), fuzzer_path, mutation_num, seed_path)
          print("Fuzzing done.")
          de_dup_process(core_index, program_path, "%s/outcomes-%d/output" % (test_path, core_index), "%s/outcomes-%d/input" % (test_path, core_index))
          print("Deduplicating done.")
          #testing_process(core_index, "%s/outcomes-%d/input" % (test_path, core_index), "%s/outcomes-%d/err" % (test_path, core_index), program_path)
          #print("Testing done.")

'''
Wrapper for run_radamsa_subprocess, can kill a process after timeout.
Timeout is implemented as an alarm.
'''
def run_fuzzer_with_alarm(core_index, test_path, program_path, fuzzer_path, seed_path, mutation_num, timeout):
    try:
        signal.signal(signal.SIGALRM,handler)
        signal.alarm(timeout)
        run_radamsa_subprocess(core_index, test_path, program_path, fuzzer_path, seed_path, mutation_num)
    except Exception as e:
        print(e)
    finally: 
        signal.alarm(0)
    print("Alarm wrapper for run_fuzzer_subprocess # %d ends" % core_index)  #alarm ends
     
     
'''
Use an alarm to control when to kill a process.
Work inside a process.
'''
def handler(signum, frame):
    raise Exception("timeout...") #when the alarm ends, call handler.

'''
Use multiprocessing.Pool to run several processes at the same time.
@param:
indexlist: a list of core index
cores: how many cores are used.
'''
def parallel_run_radamsa_with_timeout (indexlist, cores, test_path, program_path, fuzzer_path, seed_path, mutation_num, timeout):
    pool= multiprocessing.Pool(cores)
    try:
        for i in indexlist:
            pool.apply_async(func = run_fuzzer_with_alarm, args = (i,test_path, program_path, fuzzer_path, seed_path, mutation_num, timeout,))
    except Exception as e:
        print(e)
    pool.close()
    pool.join()
   


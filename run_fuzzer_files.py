import os
import sys
import multiprocessing
import datetime
import shutil
import subprocess

from utils.Config.Config import Config
from utils.GetFunctions.GetFunctions import get_range


'''
indexlist: the list of all cores
cores: the number of cores assigned.
'''
def run_fuzzer(indexlist, cores):
    pool= multiprocessing.Pool(cores)
    pool.map(run_fuzzer_subprocess, indexlist)
    pool.close()
    pool.join()
    return
   
'''
Get the system now time in timestamp.
'''   
def get_now_timestamp():
    time_now = datetime.datetime.now()
    timestamp = datetime.datetime.timestamp(time_now)
    return str(timestamp)
 
'''
Make a dir, if its parent dir doesn't exist, create it.
If the dir already exists, ERROR
path: the dir to make
'''
def mkdir(path):
    path = path.strip() #remove the begining spaces
    path = path.rstrip("\\") #remove spaces in the end
    isExist = os.path.exists(path) #Determine whether a path exists or not.
    if not isExist:
        print (path + " was successfully created.")
        os.makedirs(path)
        return True
    else:
        return False
    
'''
Remove a dir if it exists, or execpt and error.
'''  
def rmdir(path):
    try:
        shutil.rmtree(path)
    except OSError as e:
        print("ERROR: %s - %s." % (e.filename, e.strerror))
    
'''
Copy a file from source to destination
'''
def copyfile(source, dest):
    if os.path.isfile(source):
        shutil.copyfile(source, dest)
    else:
        print("ERROR: %s is not an valid file." % source)

'''
Run a command line
'''
def run_cmd(cmd):
    
    p = subprocess.Popen(cmd, shell = True, stdout = subprocess.PIPE, stderr = subprocess.PIPE)
    return p
    
'''
#Initializing
#mkdir for core_index: outcome_1. 
#if outcome_1 exists, clean the /out dir under it.
#    rmdir: outcome_1/out/*, if not exists, except an error. 
#else create subdir: out & err
#    mkdir:outcome_1/out, outcome_1/err
'''
def init_process(outcomes_path, core_index=1):

    dir_existed = mkdir(outcomes_path)
    
    if dir_existed:
        mkdir("%s/out" % outcomes_path)
        mkdir("%s/err" % outcomes_path)
    else:
        print("%s already exists" % outcomes_path)
        #rmdir("%s/out" % outcomes_path)

'''
Fuzzing:
Run cmd line to generate mutated outputs.
Save outputs as outcome_*/out/id_*;timestampe_*
@param: fuzzer_name and other option
'''
def fuzzing_process(outcomes_path, core_index=1):
    
    fuzzer_run_cmd = "%s -o %s/out/id_%s -n %d %s" % (fuzzer_path,outcomes_path, "%n", mutation_num, seed_path)
    fuzzer_return = run_cmd(fuzzer_run_cmd)
    
    fuzzer_out, fuzzer_err = fuzzer_return.communicate()
    

'''
Testing:
Use outputs generated by the fuzzer to test the program cxxfilt.
@param: testing program_name
'''
def testing_process(input_path, input_index, outcomes_path,core_index = 1):

    test_cmd = "%s < %s/id_%d" % (program_path, input_path, input_index)
    test_return = run_cmd(test_cmd)
    
    test_out, test_err = test_return.communicate()
    
    #If the input crashes the program, copy it to err/ dir.
    if test_err:
          print("ERROR %d" % input_index)
          #print(test_err)
          input_source = "%s/id_%d" % (input_path, input_index)
          err_destination = "%s/err/id_%d;timestamp_%s" % (outcomes_path,input_index, get_now_timestamp())
          copyfile(input_source, err_destination)

'''
Run the fuzzing&testing subprocess:
Initialization, fuzzing, testing.
'''
def run_fuzzer_subprocess(core_index=1):
    
    outcomes_path = "%s/outcomes-%d" % (test_path, core_index)
    init_process(outcomes_path,core_index)
    fuzzing_process(outcomes_path,core_index)
    
    for index in range(1, mutation_num + 1):
        input_path = "%s/out" % (outcomes_path)
        testing_process(input_path, index, outcomes_path,core_index)

'''
main:
1. Read arguments from the config file.
2. Multiprocessing run fuzzer, run testing program, decide the outputs
3. Output file format, name
'''

#Manually check the invalid output:
#/home/zenong/binutils_gdb/Benchmark_script/program_files/1_371517f576f8e7b25fc228c7459d6865c13d524/binutils/cxxfilt < /home/demideng/72h-cxxfilt-radamsa/err/outcomes_3/invalid_output_1

if __name__ == "__main__":
  
  lower, upper = get_range()
  
  config = Config()
  
  global timeout
  timeout = config.get_config("timeout")
  timeout = int(timeout)
  
  global fuzzer_path
  fuzzer_path = config.get_config("fuzzer_path")
  
  global seed_path
  seed_path = config.get_config("seed_path")
  
  global test_path
  test_path = config.get_config("test_path")
  output_path = "%s/out" % (test_path)
  err_path = "%s/err" % (test_path)
  
  global mutation_num
  mutation_num = config.get_config("mutation_num")
  mutation_num = int(mutation_num)

  global program_path
  program_path = config.get_config("program_path")
  
  index_list = list(range(lower,upper))#Decide which cores to use.
  
  #run_fuzzer(index_list, upper - lower + 1)
  run_fuzzer_subprocess(1)

  
'''
TODO: 11-1
How to control the timeout.
A single process to control all the other processes.
Another way: hang on each process within the process itself. wait?

Error: not valid for multiprocessing.

  TIMEOUT = 10

  process = multiprocessing.Process(target=run_fuzzer_subprocess)
  process.daemon = True
  process.start()
  
  process.join(TIMEOUT)
  if process.is_alive():
      print("Function is hanging!")
      process.terminate()
      print("Terminated!") 
'''

import multiprocessing

from utils.Commit.Commit import read_commits
from utils.Config.Config import Config
from utils.ErrorInput.ErrorInput import read_inputs_from_file, dump_inputs_into_pickle
from utils.GetFunctions.GetFunctions import get_core_number, get_range
from supports.map_to_commit import map_to_commit, map_by_timeline

'''
Process fuzzing outcomes.
core_id: fuzzing outcomes generated by different cores, each dir has a unique id. It's used to refer to a specific dir #.
fuzzing_output_path: the path of fuzzing outcomes. e.g., 72h-cxxfilt-radamsa.
arg: the testing cmd, e.g, binutils/cxxfilt <
commits: a file that store several commits # of the tested program.
program_path: dir of the tested program, which contains several versions of programs, and commits file. 

output_table_path: specify a directory to store mappting results.
Two mapping files will be generated in this process, input_mapping_# and time_mapping_#.
'''
def map_inputs(core_id):

    error_path = "%s/outcomes-%d/err" % (fuzzing_output_path, core_id)
    
    inputs = read_inputs_from_file("%s/" % error_path)
    
    # create the input mapping log files
    with open("%s/input_mapping_%d" % (output_table_path, core_id), "w+") as mapping:
        map_to_commit(commits, inputs, arg, program_path, mapping, core_id)
    with open("%s/time_mapping_%d" % (output_table_path, core_id), "w+") as time_mapping:
        map_by_timeline(inputs, time_mapping)
    print("Core_%d has ended." % core_id)
    return inputs


if __name__ == '__main__':
    config = Config()

    global commits
    commits = read_commits(config.get_config("commits file path"))
    #commits is an object.

    global arg
    arg = config.get_run_command()

    global program_path
    program_path = config.get_program_path()

    global afl_output_path
    fuzzing_output_path = config.get_config("fuzzing output path")
    
    global output_table_path
    output_table_path = config.get_config("output table path")

    pickle_path = config.get_config("pickle path")

    print("\033[93mcommand to run the program is like [directory]/%s [target]\x1b[0m" % arg)
    input("Press Enter to continue...")

    lower, upper = get_range()
    cores = upper - lower + 1
    pool = multiprocessing.Pool(cores)
    inputs = pool.map(map_inputs, list(range(lower, upper + 1)))
        
    pool.close()
    pool.join()

    #All results will be stored as a pickle.
    dump_inputs_into_pickle(inputs, pickle_path)
